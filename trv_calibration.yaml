---
blueprint:
  name: Calibrate TRV
  description: Use an external sensor to calibrate a TRV
  domain: automation
  input:
    trv_sensor:
      name: TRV
      description: the TRV to calibrate
      selector:
        entity:
          filter:
            - domain: climate
              integration: zha
              supported_features:
                - climate.ClimateEntityFeature.TARGET_TEMPERATURE
    remote_sensor:
      name: Remote Sensor
      description: the sensor to hook to this TRV
      selector:
        entity:
          filter:
            - domain: sensor
              device_class: temperature
    local_offset:
      name: Offset via Zigbee
      description: >
          the offset on the radiator TRV,
          we have to ask as not predictable
      selector:
        entity:
          filter:
            - domain: number
              integration: zha
    threshold:
      name: Threshold for making changes
      description: >
          changes in temperature offset of less than this are ignored.
          This number must be positive as it compared to abs(old-new)
      default: 0.2
      selector:
        number:
          min: 0.1
          max: 1.0
          step: 0.1
          unit_of_measurement: "Â°C"
    alpha:
      name: Damping factor (0 = all new input)
      description: >
          Amount of old sensor value to stir in, sensible values from
          zero (all new) to 0.25 (add in a quarter of the old value)
      default: 0.2
      selector:
        number:
          min: 0
          max: 0.5
          step: 0.05

variables:
  local_offset: !input local_offset
  remote_sensor: !input remote_sensor
  trv_sensor: !input trv_sensor
  threshold: !input threshold
  alpha: !input alpha
  invalid_inputs: |
     {{ is_state(remote_sensor, ['unknown', 'unavailable']) or
        is_state(trv_sensor, ['unknown', 'unavailable']) or
        is_state(local_offset, ['unknown', 'unavailable']) }}
  old_offset: "{{ states(local_offset)|float(0) }}"
  trv_raw: "{{ state_attr (trv_sensor, 'current_temperature')|float(0) - old_offset }}"
  new_offset: "{{ states(remote_sensor)|float(0) - trv_raw }}"
  damped_offset: "{{ ((1-alpha) * new_offset + alpha * old_offset)|round(precision=1) }}"
  offset_changed: "{{ (old_offset - damped_offset)|abs >= threshold }}"
  sensible_offset: "{{ damped_offset|abs < 4 }}"

triggers:
  - trigger: state
    entity_id:
      - !input remote_sensor
    for:
      seconds: 30
  - trigger: state
    entity_id:
      - !input trv_sensor
    attribute: current_temperature
    for:
      seconds: 30

conditions: "{{ not invalid_inputs and offset_changed and sensible_offset }}"

actions:
  - action: number.set_value
    metadata: {}
    data:
      value: "{{ damped_offset }}"
    target:
      entity_id: "{{ local_offset }}"
  # we will probably get called back once we change the offset, because
  # the recorded temperature will change.  It should calculate the same
  # offset and therefore offset_changed will be false. But to avoid 
  # any possibility of a loop we delay here to abort any
  # callback that gets through the conditions: section.
  - delay:
      minutes: 1
